<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fertilization Simulation</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #fde0e0; /* Light pinkish background */
            color: #333;
            margin: 0;
            overflow: hidden;
        }
        #simulationCanvas {
            border: 1px solid #c08080;
            background-color: #ffe8e8; /* Slightly darker pink */
            display: block; /* Prevents extra space below */
            margin: 10px auto;
        }
        #controls {
            margin-top: 15px;
        }
        button {
            padding: 8px 15px;
            font-size: 1em;
            cursor: pointer;
            background-color: #e89090;
            color: white;
            border: none;
            border-radius: 5px;
            margin: 0 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #d87070;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
            min-height: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Fertilization Simulation</h1>
    <canvas id="simulationCanvas" width="600" height="400"></canvas>
    <div id="controls">
        <button id="startButton">Start Simulation</button>
        <button id="resetButton" disabled>Reset</button>
    </div>
    <p id="status">Status: Ready</p>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        // --- Simulation Parameters ---
        const SPERM_COUNT = 50;
        const SPERM_SPEED_BASE = 1;
        const SPERM_SPEED_VARIATION = 0.8;
        const SPERM_SIZE_HEAD = 3;
        const SPERM_SIZE_TAIL = 10;
        const EGG_RADIUS = 40;
        const EGG_POS = { x: canvas.width - EGG_RADIUS - 50, y: canvas.height / 2 };
        const FERTILIZATION_ZONE_RADIUS = EGG_RADIUS + SPERM_SIZE_HEAD / 2; // Collision radius
        const ZYGOTE_COLOR = '#ff8080'; // Color after fertilization
        const ZYGOTE_NUCLEUS_COLOR = '#a00000';

        // --- State Variables ---
        let spermArray = [];
        let animationFrameId = null;
        let isSimulating = false;
        let isFertilized = false;
        let winnerSperm = null;
        let zygoteFormationProgress = 0; // 0 to 1

        // --- Helper Functions ---
        function getRandom(min, max) {
            return Math.random() * (max - min) + min;
        }

        // --- Drawing Functions ---
        function drawEgg() {
            // Outer membrane
            ctx.beginPath();
            ctx.arc(EGG_POS.x, EGG_POS.y, EGG_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = isFertilized ? '#ffd0d0' : '#ffcccc'; // Slightly change color if fertilized
            ctx.fill();
            ctx.strokeStyle = '#e8a0a0';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Nucleus
            ctx.beginPath();
            ctx.arc(EGG_POS.x + EGG_RADIUS * 0.1, EGG_POS.y - EGG_RADIUS * 0.1, EGG_RADIUS * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#fca0a0';
            ctx.fill();

            // Fertilization effect / Zygote nucleus visual
            if (isFertilized && zygoteFormationProgress > 0) {
                ctx.beginPath();
                // Growing merged nucleus
                const nucleusRadius = EGG_RADIUS * 0.3 + (EGG_RADIUS * 0.2 * zygoteFormationProgress);
                ctx.arc(EGG_POS.x, EGG_POS.y, nucleusRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(160, 0, 0, ${0.5 + 0.5 * zygoteFormationProgress})`; // Darker, fades in
                ctx.fill();

                 // Draw a thicker "zona pellucida" effect
                 ctx.strokeStyle = `rgba(255, 128, 128, ${0.5 * zygoteFormationProgress})`;
                 ctx.lineWidth = 4 + 4 * zygoteFormationProgress;
                 ctx.stroke(); // Re-stroke the main egg circle
            }
        }

        function drawSperm(sperm, time) {
            // Head
            ctx.beginPath();
            ctx.arc(sperm.x, sperm.y, SPERM_SIZE_HEAD, 0, Math.PI * 2);
            ctx.fillStyle = sperm.isWinner ? '#0000ff' : '#555599'; // Highlight winner
             if (sperm.fading) {
                ctx.fillStyle = `rgba(85, 85, 153, ${sperm.opacity})`;
            }
            ctx.fill();

            // Tail - simple line with wiggle
            const angle = Math.atan2(sperm.vy, sperm.vx);
            const tailWiggle = Math.sin(time * 0.05 * sperm.speed + sperm.offset) * (Math.PI / 8); // Wiggle based on time, speed, and offset
            const tailAngle = angle + Math.PI + tailWiggle; // Opposite direction + wiggle

            ctx.beginPath();
            ctx.moveTo(sperm.x, sperm.y);
            ctx.lineTo(
                sperm.x + Math.cos(tailAngle) * SPERM_SIZE_TAIL,
                sperm.y + Math.sin(tailAngle) * SPERM_SIZE_TAIL
            );
            ctx.strokeStyle = sperm.isWinner ? '#0000ff' : '#555599';
             if (sperm.fading) {
                ctx.strokeStyle = `rgba(85, 85, 153, ${sperm.opacity})`;
            }
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- Simulation Logic ---
        function createSperm() {
            const y = getRandom(SPERM_SIZE_HEAD, canvas.height - SPERM_SIZE_HEAD);
            const speed = SPERM_SPEED_BASE + getRandom(-SPERM_SPEED_VARIATION, SPERM_SPEED_VARIATION);
            return {
                x: -SPERM_SIZE_TAIL, // Start off-screen left
                y: y,
                vx: 0, // Velocity components
                vy: 0,
                speed: Math.max(0.2, speed), // Ensure minimum speed
                offset: getRandom(0, Math.PI * 2), // For unique tail wiggle
                isActive: true, // Still moving towards egg
                isWinner: false,
                fading: false,
                opacity: 1
            };
        }

        function updateSperm(sperm) {
            if (!sperm.isActive) {
                 if (sperm.fading) {
                    sperm.opacity -= 0.01; // Fade out speed
                    if (sperm.opacity <= 0) sperm.opacity = 0;
                }
                return; // Don't move if inactive or fertilized
            }

            // Calculate vector towards egg center
            const dx = EGG_POS.x - sperm.x;
            const dy = EGG_POS.y - sperm.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Simple directional movement + slight randomness
            const angleToEgg = Math.atan2(dy, dx);
            const randomAngleVariation = getRandom(-Math.PI / 16, Math.PI / 16); // Add wobble
            const moveAngle = angleToEgg + randomAngleVariation;

            // Update velocity (normalized direction * speed)
            sperm.vx = Math.cos(moveAngle) * sperm.speed;
            sperm.vy = Math.sin(moveAngle) * sperm.speed;

            // Update position
            sperm.x += sperm.vx;
            sperm.y += sperm.vy;

            // Collision check
            if (!isFertilized && distance < FERTILIZATION_ZONE_RADIUS) {
                isFertilized = true;
                winnerSperm = sperm;
                sperm.isWinner = true;
                sperm.isActive = false; // Winner stops at the edge
                sperm.x = EGG_POS.x - Math.cos(angleToEgg) * EGG_RADIUS; // Place on egg edge
                sperm.y = EGG_POS.y - Math.sin(angleToEgg) * EGG_RADIUS;

                statusElement.textContent = "Status: Fertilization! Forming zygote...";

                // Stop other sperm and make them fade
                spermArray.forEach(s => {
                    if (s !== winnerSperm) {
                        s.isActive = false;
                        s.fading = true;
                    }
                });
            }

            // Deactivate sperm far past the egg
            if (sperm.x > canvas.width + SPERM_SIZE_TAIL) {
                sperm.isActive = false;
            }
             // Deactivate sperm hitting top/bottom
            if (sperm.y < 0 || sperm.y > canvas.height) {
                 sperm.isActive = false;
                 sperm.fading = true; // Make them fade if they hit walls
            }
        }


        function gameLoop(timestamp) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Egg / Zygote
            drawEgg();

            // Update and Draw Sperm
            let activeSpermCount = 0;
            spermArray.forEach(sperm => {
                if(sperm.opacity > 0) { // Only update/draw if visible
                    if (!isFertilized || sperm.isWinner || sperm.fading) {
                       updateSperm(sperm);
                       drawSperm(sperm, timestamp);
                    }
                    if(sperm.isActive) activeSpermCount++;
                }
            });

             // Update Zygote Formation
            if (isFertilized && zygoteFormationProgress < 1) {
                zygoteFormationProgress += 0.005; // Speed of zygote visual change
                if (zygoteFormationProgress >= 1) {
                    zygoteFormationProgress = 1;
                    if (!statusElement.textContent.includes("complete")) {
                        statusElement.textContent = "Status: Zygote formation complete.";
                    }
                     // Optionally fade winner sperm after zygote forms
                    if (winnerSperm && !winnerSperm.fading) {
                         //winnerSperm.fading = true; // Uncomment to make winner fade
                    }
                }
            }

            // Stop simulation if no active sperm and not fertilized, or after zygote formed
             const simulationEnded = (activeSpermCount === 0 && !isFertilized) || (isFertilized && zygoteFormationProgress >= 1);

            if (isSimulating && !simulationEnded) {
                 animationFrameId = requestAnimationFrame(gameLoop);
            } else if (isSimulating && simulationEnded && !statusElement.textContent.includes("complete") && !isFertilized) {
                 statusElement.textContent = "Status: Simulation ended. No fertilization.";
                 isSimulating = false;
                 resetButton.disabled = false; // Allow reset
            } else if (isSimulating && simulationEnded && isFertilized) {
                 // Already handled zygote formation complete message
                 isSimulating = false;
                 resetButton.disabled = false; // Allow reset
            } else {
                 isSimulating = false; // Ensure state is correct if stopped early
            }
        }

        // --- Control Functions ---
        function startSimulation() {
            if (isSimulating) return;

            resetSimulationState(); // Clear previous state if any

            isSimulating = true;
            startButton.disabled = true;
            resetButton.disabled = true; // Disable reset during run
            statusElement.textContent = "Status: Simulation running...";

            // Create initial sperm
            for (let i = 0; i < SPERM_COUNT; i++) {
                spermArray.push(createSperm());
            }

            // Cancel any previous loop and start anew
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function resetSimulationState() {
             // Stop the animation loop
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Clear data
            spermArray = [];
            isSimulating = false;
            isFertilized = false;
            winnerSperm = null;
            zygoteFormationProgress = 0;

             // Reset UI elements
            startButton.disabled = false;
            resetButton.disabled = true;
            statusElement.textContent = "Status: Ready";

            // Clear canvas and redraw initial state (just the egg)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawEgg();
        }


        // --- Event Listeners ---
        startButton.addEventListener('click', startSimulation);
        resetButton.addEventListener('click', resetSimulationState);

        // --- Initial Draw ---
        window.onload = () => {
            drawEgg(); // Draw the initial egg when the page loads
        };

    </script>
</body>
</html>