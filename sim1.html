<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fertilization & Mitosis Simulation</title>
    <style>
        body { margin: 0; font-family: sans-serif; overflow: hidden; background-color: #050510; color: #eee; display: flex; flex-direction: column; align-items: center; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; display:block; background-color: rgba(0,0,0,0.6); padding: 5px 0; }
        h1 { margin: 5px 0; }
        #controls { margin-top: 5px; }
        button { padding: 8px 15px; font-size: 0.9em; cursor: pointer; background-color: #4a4a6a; color: #e0e0e0; border: none; border-radius: 5px; margin: 0 5px; transition: background-color 0.3s; }
        button:hover { background-color: #5a5a7a; }
        button:disabled { background-color: #333; color: #777; cursor: not-allowed; }
        #status { margin-top: 5px; font-style: italic; min-height: 1.2em;}
    </style>
</head>
<body>
    <div id="info">
        <h1>3D Fertilization & Mitosis</h1>
        <p id="status">Status: Ready</p>
        <div id="controls">
            <button id="startButton">Start Simulation</button>
            <button id="resetButton" disabled>Reset</button>
        </div>
    </div>
    <div id="container"></div>

    <!-- Import Three.js Library -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Basic Setup ---
        const container = document.getElementById('container');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');

        let scene, camera, renderer, clock;
        let egg, spermArray = [], lights = {};
        let chromosomeMeshes = [], daughterCells = []; // For Mitosis
        let animationFrameId = null;

        // --- State Variables ---
        let isSimulating = false;
        let isFertilized = false;
        let winnerSperm = null;
        let zygoteFormationProgress = 0; // 0 to 1
        let mitosisState = 'NONE'; // NONE, PROPHASE, METAPHASE, ANAPHASE, TELOPHASE, COMPLETE
        let mitosisProgress = 0; // 0 to 1 for the current stage

        // --- Simulation Parameters ---
        const SPERM_COUNT = 40; // Reduced slightly for performance
        const SPERM_SPEED = 0.3;
        const SPERM_WIGGLE_SPEED = 15;
        const SPERM_WIGGLE_AMOUNT = 0.15;
        const SPERM_HEAD_RADIUS = 0.3;
        const SPERM_TAIL_LENGTH = 2.5;
        const EGG_RADIUS = 6; // Slightly larger egg
        const FERTILIZATION_DISTANCE = EGG_RADIUS + SPERM_HEAD_RADIUS;
        const SCENE_BOUNDS = 45;

        const EGG_COLOR_INITIAL = 0xffcccc;
        const EGG_COLOR_FERTILIZED = 0xffaacc;
        const ZYGOTE_NUCLEUS_COLOR = 0xaa0055;
        const SPERM_COLOR = 0xeeeeff;
        const WINNER_SPERM_COLOR = 0xccccff;
        const CHROMOSOME_COLOR = 0xffee88; // Yellowish
        const DAUGHTER_CELL_COLOR = 0xffdddd;

        // Mitosis Parameters
        const NUM_CHROMOSOMES = 8; // Simplified representation
        const CHROMOSOME_RADIUS = 0.2;
        const PROPHASE_DURATION = 4.0; // Seconds
        const METAPHASE_DURATION = 4.0;
        const ANAPHASE_DURATION = 3.0;
        const TELOPHASE_DURATION = 5.0;
        const POLE_DISTANCE_FACTOR = 0.6; // How far chromosomes move towards poles (relative to egg radius)


        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x050510, SCENE_BOUNDS * 0.7, SCENE_BOUNDS * 1.5);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = SCENE_BOUNDS * 0.6;
            camera.position.y = SCENE_BOUNDS * 0.1;
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x050510);
            container.appendChild(renderer.domElement);

            lights.ambient = new THREE.AmbientLight(0x404060, 1.8);
            scene.add(lights.ambient);
            lights.directional = new THREE.DirectionalLight(0xffffff, 1.0);
            lights.directional.position.set(5, 10, 7.5);
            scene.add(lights.directional);

            // Egg
            const eggGeometry = new THREE.SphereGeometry(EGG_RADIUS, 32, 24);
            const eggMaterial = new THREE.MeshPhongMaterial({
                color: EGG_COLOR_INITIAL,
                shininess: 20,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide // Render inside for mitosis view
            });
            egg = new THREE.Mesh(eggGeometry, eggMaterial);
            scene.add(egg);

            // Zygote Nucleus (initially hidden within egg)
            const nucleusGeo = new THREE.SphereGeometry(EGG_RADIUS * 0.3, 16, 16);
            const nucleusMat = new THREE.MeshBasicMaterial({
                color: ZYGOTE_NUCLEUS_COLOR,
                transparent: true,
                opacity: 0,
                visible: false // Start invisible
            });
            egg.nucleus = new THREE.Mesh(nucleusGeo, nucleusMat);
            egg.add(egg.nucleus); // Add as child

            // Pre-create chromosome meshes (hidden)
            const chromosomeGeo = new THREE.SphereGeometry(CHROMOSOME_RADIUS, 6, 6);
            const chromosomeMat = new THREE.MeshPhongMaterial({ color: CHROMOSOME_COLOR, shininess: 40 });
            for (let i = 0; i < NUM_CHROMOSOMES; i++) {
                const chromo = new THREE.Mesh(chromosomeGeo, chromosomeMat.clone()); // Clone material
                chromo.visible = false;
                // Store target pole and initial position reference
                chromo.userData = {
                    targetPole: (i < NUM_CHROMOSOMES / 2) ? 1 : -1, // Assign half to each pole for Anaphase
                    metaphaseTarget: new THREE.Vector3(),
                    anaphaseTarget: new THREE.Vector3()
                 };
                chromosomeMeshes.push(chromo);
                egg.add(chromo); // Add as child of egg
            }

            // Pre-create Daughter Cell meshes (hidden)
             const daughterGeo = new THREE.SphereGeometry(EGG_RADIUS * 0.5, 16, 12); // Start size
             const daughterMat = new THREE.MeshPhongMaterial({
                color: DAUGHTER_CELL_COLOR,
                transparent: true,
                opacity: 0,
                shininess: 15
            });
            for(let i=0; i<2; i++){
                const cell = new THREE.Mesh(daughterGeo, daughterMat.clone());
                cell.visible = false;
                daughterCells.push(cell);
                egg.add(cell); // Add as child of egg
            }


            window.addEventListener('resize', onWindowResize, false);
            startButton.addEventListener('click', startSimulation);
            resetButton.addEventListener('click', resetSimulation);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Sperm Creation (Identical to previous version) ---
        function createSperm() {
            const group = new THREE.Group();
            const headGeometry = new THREE.SphereGeometry(SPERM_HEAD_RADIUS, 8, 8);
            const headMaterial = new THREE.MeshPhongMaterial({ color: SPERM_COLOR, shininess: 50 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            group.add(head);
            const tailGeometry = new THREE.CylinderGeometry(SPERM_HEAD_RADIUS * 0.2, SPERM_HEAD_RADIUS * 0.1, SPERM_TAIL_LENGTH, 6);
            const tailMaterial = new THREE.MeshPhongMaterial({ color: SPERM_COLOR, shininess: 20 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.z = -SPERM_TAIL_LENGTH / 2 - SPERM_HEAD_RADIUS * 0.5;
            tail.rotation.x = Math.PI / 2;
            group.add(tail);

            const distance = SCENE_BOUNDS * 0.8;
            const angle = Math.random() * Math.PI * 2;
            const yAngle = (Math.random() - 0.5) * Math.PI * 0.8;
            group.position.x = Math.cos(angle) * Math.cos(yAngle) * distance;
            group.position.y = Math.sin(yAngle) * distance;
            group.position.z = Math.sin(angle) * Math.cos(yAngle) * distance;
            group.lookAt(egg.position);

            group.userData = {
                velocity: group.getWorldDirection(new THREE.Vector3()).multiplyScalar(SPERM_SPEED),
                speed: SPERM_SPEED * (0.8 + Math.random() * 0.4),
                isActive: true, isWinner: false, fading: false,
                wiggleOffset: Math.random() * Math.PI * 2,
                head: head, tail: tail
            };
            spermArray.push(group);
            scene.add(group);
        }

         // --- Sperm Update (Handles fertilization trigger) ---
        function updateSperm(sperm, delta, time) {
            const data = sperm.userData;
            if (!data.isActive) { /* ... (fading logic same as before) ... */
                if (data.fading) {
                    const headMat = data.head.material; const tailMat = data.tail.material;
                    if (headMat.opacity > 0) {
                        headMat.transparent = true; tailMat.transparent = true;
                        headMat.opacity -= 0.8 * delta; tailMat.opacity -= 0.8 * delta;
                    } else {
                         if (sperm.parent) scene.remove(sperm); // Remove fully faded
                    }
                }
                 return;
            }

            const directionToEgg = egg.position.clone().sub(sperm.position).normalize();
            const wobble = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.1);
            const targetDirection = directionToEgg.add(wobble).normalize();
            data.velocity.lerp(targetDirection.multiplyScalar(data.speed), 0.05);
            sperm.position.addScaledVector(data.velocity, delta);
            sperm.lookAt(sperm.position.clone().add(data.velocity));

            const wiggleAngle = Math.sin(time * SPERM_WIGGLE_SPEED + data.wiggleOffset) * SPERM_WIGGLE_AMOUNT;
            data.tail.rotation.y = wiggleAngle;

            const distanceToEgg = sperm.position.distanceTo(egg.position);
            if (!isFertilized && distanceToEgg < FERTILIZATION_DISTANCE) {
                isFertilized = true;
                winnerSperm = sperm;
                data.isWinner = true;
                data.isActive = false;
                const surfaceDirection = sperm.position.clone().sub(egg.position).normalize();
                sperm.position.copy(egg.position).addScaledVector(surfaceDirection, EGG_RADIUS + SPERM_HEAD_RADIUS * 0.5);
                sperm.lookAt(egg.position);
                statusElement.textContent = "Status: Fertilization! Forming zygote...";
                egg.material.color.setHex(EGG_COLOR_FERTILIZED);
                data.head.material.color.setHex(WINNER_SPERM_COLOR);
                data.tail.material.color.setHex(WINNER_SPERM_COLOR);

                egg.scale.set(1.05, 1.05, 1.05); // Slight pulse
                setTimeout(() => egg.scale.set(1, 1, 1), 150);

                spermArray.forEach(s => {
                    if (s !== winnerSperm) {
                        s.userData.isActive = false; s.userData.fading = true;
                        s.userData.head.material.opacity = 1.0; s.userData.tail.material.opacity = 1.0;
                    }
                });
            }
            if (sperm.position.length() > SCENE_BOUNDS * 1.2) {
                data.isActive = false; data.fading = true;
                data.head.material.opacity = 1.0; data.tail.material.opacity = 1.0;
            }
        }


        // --- Mitosis Update Logic ---
        function updateMitosis(delta) {
            if (mitosisState === 'NONE' || mitosisState === 'COMPLETE') return;

            mitosisProgress += delta;
            let stageDuration;
            let progressRatio = 0; // Progress within the current stage (0 to 1)

            switch (mitosisState) {
                case 'PROPHASE':
                    stageDuration = PROPHASE_DURATION;
                    progressRatio = Math.min(1.0, mitosisProgress / stageDuration);
                    statusElement.textContent = "Status: Mitosis - Prophase";

                    // Fade in chromosomes, fade out nucleus
                    const nucleusOpacity = 1.0 - progressRatio;
                    egg.nucleus.material.opacity = nucleusOpacity > 0 ? nucleusOpacity : 0;
                     if(nucleusOpacity <= 0) egg.nucleus.visible = false;

                    chromosomeMeshes.forEach((chromo, i) => {
                        chromo.visible = true;
                        chromo.material.opacity = progressRatio;
                        // Simple random movement to simulate condensation/activity
                        chromo.position.x += (Math.random() - 0.5) * 0.05 * delta * 60;
                        chromo.position.y += (Math.random() - 0.5) * 0.05 * delta * 60;
                        chromo.position.z += (Math.random() - 0.5) * 0.05 * delta * 60;
                         // Keep inside nucleus radius roughly
                        chromo.position.clampLength(0, EGG_RADIUS * 0.4);
                    });

                    if (progressRatio >= 1.0) {
                        mitosisState = 'METAPHASE';
                        mitosisProgress = 0; // Reset progress for next stage
                        // Calculate target positions on metaphase plate (XY plane)
                         chromosomeMeshes.forEach((chromo, i) => {
                             const angle = (i / NUM_CHROMOSOMES) * Math.PI * 2;
                             const radius = EGG_RADIUS * 0.3 * (0.5 + Math.random() * 0.5); // Random radius on plate
                             chromo.userData.metaphaseTarget.set(
                                 Math.cos(angle) * radius,
                                 Math.sin(angle) * radius,
                                 (Math.random()-0.5) * 0.1 // Slight Z variation
                             );
                         });
                    }
                    break;

                case 'METAPHASE':
                    stageDuration = METAPHASE_DURATION;
                    progressRatio = Math.min(1.0, mitosisProgress / stageDuration);
                    statusElement.textContent = "Status: Mitosis - Metaphase";

                    // Move chromosomes to metaphase plate
                     chromosomeMeshes.forEach(chromo => {
                        chromo.position.lerp(chromo.userData.metaphaseTarget, 0.1 * progressRatio); // Smooth move
                     });

                    if (progressRatio >= 1.0) {
                        mitosisState = 'ANAPHASE';
                        mitosisProgress = 0;
                        // Calculate target pole positions
                        const poleDist = EGG_RADIUS * POLE_DISTANCE_FACTOR;
                        chromosomeMeshes.forEach(chromo => {
                             chromo.userData.anaphaseTarget.set(
                                 chromo.position.x * 0.3, // Move slightly inwards horizontally
                                 chromo.position.y * 0.3,
                                 chromo.userData.targetPole * poleDist // Move to assigned pole Z
                             );
                         });
                    }
                    break;

                case 'ANAPHASE':
                    stageDuration = ANAPHASE_DURATION;
                    progressRatio = Math.min(1.0, mitosisProgress / stageDuration);
                    statusElement.textContent = "Status: Mitosis - Anaphase";

                    // Move chromosomes to poles
                     chromosomeMeshes.forEach(chromo => {
                         chromo.position.lerp(chromo.userData.anaphaseTarget, 0.15 * progressRatio); // Move faster
                     });

                    // Optional: Slight cell elongation (barely noticeable)
                    // egg.scale.z = 1.0 + 0.05 * progressRatio;

                    if (progressRatio >= 1.0) {
                        mitosisState = 'TELOPHASE';
                        mitosisProgress = 0;
                         egg.scale.z = 1.0; // Reset scale
                    }
                    break;

                case 'TELOPHASE':
                    stageDuration = TELOPHASE_DURATION;
                    progressRatio = Math.min(1.0, mitosisProgress / stageDuration);
                    statusElement.textContent = "Status: Mitosis - Telophase (Cytokinesis)";

                    // Fade out chromosomes, fade in daughter cells
                    const visibilityProgress = THREE.MathUtils.smoothstep(progressRatio, 0.2, 0.8); // Fade chromo later
                    chromosomeMeshes.forEach(chromo => {
                         chromo.material.transparent = true;
                         chromo.material.opacity = 1.0 - visibilityProgress;
                         if(chromo.material.opacity <= 0) chromo.visible = false;
                     });

                    // Position and reveal daughter cells
                    const poleDist = EGG_RADIUS * POLE_DISTANCE_FACTOR * 0.8; // Center of daughter cells
                    daughterCells[0].position.z = poleDist; // Pole 1
                    daughterCells[1].position.z = -poleDist; // Pole 2
                     daughterCells.forEach(cell => {
                         cell.visible = true;
                         cell.material.opacity = progressRatio * 0.8; // Fade in daughter cells
                         const scale = 0.1 + progressRatio * 0.9; // Grow daughter cells
                         cell.scale.set(scale, scale, scale);
                     });

                    if (progressRatio >= 1.0) {
                        mitosisState = 'COMPLETE';
                        statusElement.textContent = "Status: Mitosis Complete - Two Daughter Cells";
                        // Keep daughter cells visible
                    }
                    break;
            }
        }

        // --- Main Animation Loop ---
        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            if (!isSimulating && mitosisState === 'NONE') return; // Only stop if truly inactive

            let activeSpermCount = 0;
            // Update sperm (iterate backwards if removing elements)
            if (!isFertilized || winnerSperm) { // Stop updating sperm once winner is gone and fertilized
                 for (let i = spermArray.length - 1; i >= 0; i--) {
                     const sperm = spermArray[i];
                     updateSperm(sperm, delta, time);
                     if (sperm.userData.isActive) { activeSpermCount++; }
                     // Remove check (moved inside updateSperm's fade logic)
                 }
            }

            // Update Zygote Formation & Trigger Mitosis
            if (isFertilized && zygoteFormationProgress < 1) {
                zygoteFormationProgress += 0.3 * delta; // Speed of zygote visual change
                if (zygoteFormationProgress > 1) zygoteFormationProgress = 1;

                const nucleusProgress = THREE.MathUtils.smoothstep(zygoteFormationProgress, 0, 1);
                egg.nucleus.visible = true;
                egg.nucleus.material.opacity = nucleusProgress * 0.9;
                egg.nucleus.scale.setScalar(1.0 + nucleusProgress * 0.2);

                if (zygoteFormationProgress >= 1 && mitosisState === 'NONE') {
                    mitosisState = 'PROPHASE'; // Start mitosis
                    mitosisProgress = 0;
                    statusElement.textContent = "Status: Mitosis Initiated - Prophase";
                     // Remove winner sperm visually now
                     if(winnerSperm && winnerSperm.parent) {
                         scene.remove(winnerSperm);
                         winnerSperm = null; // Clear reference
                     }
                      // Initialize chromosome positions randomly near center
                    chromosomeMeshes.forEach(chromo => {
                        chromo.position.set(
                            (Math.random() - 0.5) * EGG_RADIUS * 0.1,
                            (Math.random() - 0.5) * EGG_RADIUS * 0.1,
                            (Math.random() - 0.5) * EGG_RADIUS * 0.1
                        );
                        chromo.material.opacity = 0; // Start invisible for fade-in
                    });
                }
            }

            // Update Mitosis Stages if active
            if (mitosisState !== 'NONE' && mitosisState !== 'COMPLETE') {
                updateMitosis(delta);
            }

            // Check simulation end conditions
            const spermGone = spermArray.every(s => !s.parent); // Check if all sperm removed from scene
            const simulationEnded = (spermGone && !isFertilized) || mitosisState === 'COMPLETE';

            if (!isSimulating && simulationEnded && resetButton.disabled) {
                 resetButton.disabled = false; // Enable reset when finished
                 if (!isFertilized && !statusElement.textContent.includes("Mitosis")) {
                      statusElement.textContent = "Status: Simulation ended. No fertilization.";
                 }
                 // Mitosis complete message handled in updateMitosis
            }

            renderer.render(scene, camera);
        }

        // --- Control Functions ---
        function startSimulation() {
            if (isSimulating || mitosisState !== 'NONE') return; // Prevent restart if mitosis started
            resetSimulation(false);

            isSimulating = true;
            startButton.disabled = true;
            resetButton.disabled = true;
            statusElement.textContent = "Status: Simulation running...";

            for (let i = 0; i < SPERM_COUNT; i++) { createSperm(); }

            if (animationFrameId === null) { animate(); }
        }

        function resetSimulation(clearSceneContent = true) {
             isSimulating = false; // Stop updates in the loop

             // Remove sperm
             spermArray.forEach(sperm => { if (sperm.parent) scene.remove(sperm); });
             spermArray = [];
             winnerSperm = null;

             // Reset fertilization state
             isFertilized = false;
             zygoteFormationProgress = 0;
             if (egg) {
                 egg.material.color.setHex(EGG_COLOR_INITIAL);
                 egg.scale.set(1, 1, 1);
                 if (egg.nucleus) {
                     egg.nucleus.visible = false;
                     egg.nucleus.material.opacity = 0;
                     egg.nucleus.scale.setScalar(1.0);
                 }
             }

             // Reset Mitosis state
             mitosisState = 'NONE';
             mitosisProgress = 0;
             chromosomeMeshes.forEach(chromo => { chromo.visible = false; });
             daughterCells.forEach(cell => { cell.visible = false; cell.material.opacity = 0; cell.scale.set(0.1,0.1,0.1);}); // Reset scale too

             // Reset UI
             startButton.disabled = false;
             resetButton.disabled = true;
             statusElement.textContent = "Status: Ready";

             // Only stop animation loop if fully resetting (might want to keep it running for camera controls etc)
             // if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

             // Render one frame of the reset state
             if (renderer) { renderer.render(scene, camera); }
        }

        // --- Run ---
        init();
        renderer.render(scene, camera); // Initial render

    </script>
</body>
</html>